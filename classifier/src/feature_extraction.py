import cProfile
import math
import os
import sys
from typing import Union

import numpy
import numpy as np
from cv2 import cv2
from numpy import ndarray

from channel_enum import ChannelYUV, ChannelRGB
from feature_config import FeatureConfig
from feature_vector import FeatureVector


def _apply_dct(block: ndarray, coefficients: list[tuple[int, int]]) -> list[float]:
    result = []
    dct = np.multiply(cv2.dct(np.divide(block, 256)), 256)
    for (x, y) in coefficients:
        result.append(dct[x][y])

    return result


def _round_nearest(x, a):
    return round(round(x / a) * a, -int(math.floor(math.log10(a))))


class FeatureExtractor:
    """
    Class that creates a feature vector of an image using DCT.

    The extracted features are represented in a histogram. The values that make up the histogram represent one
    DC/AC value of a DCT block. The DCT block is the result of applying a 2D DCT to a slice of an image. The
    slice is generated by reducing the 3D array representation into two dimensions by selecting one color
    channel. Afterwards a square piece the size of the block size is cut out.

    The following parameters can be customized:
        - DC/AC value
        - histogram bin width
        - block size
        - color channel

    The customization is done via a FeatureConfig object either at construction or via the dedicated method.
    """

    def __init__(self, config: FeatureConfig = None):
        """
        Inits FeatureExtractor with desired settings. When no configuration is provided it uses default values.

        The default values are:
            - DC/AC value = (0,0)
            - histogram bin width = 5
            - block size = 8
            - color channel = Y

        Args:
            config (FeatureConfig): Configuration object for the desired settings
        """
        self._channel: Union[ChannelRGB, ChannelYUV] = config.color_channel if config else ChannelYUV.Y
        self._dct_coefficients = config.dct_coefficients if config else [(0, 0)]
        self._block_size = config.block_size if config else 8
        self._bin_width = config.bin_width if config else 5.

    def configure_features(self, config: FeatureConfig):
        """
        Reconfigures FeatureExtractor with new settings.

        Args:
            config (FeatureConfig): Configuration object for the desired settings
        """
        self._channel = config.color_channel
        self._dct_coefficients = config.dct_coefficients
        self._block_size = config.block_size
        self._bin_width = config.bin_width

    def extract_feature_vector(self, img_path: str) -> FeatureVector:
        """
        Extracts the feature vector from the provided image.

        Args:
            img_path (str): relative path to the image

        Returns:
            A FeatureVector object that contains the generated histogram
        """
        filename = os.path.abspath(img_path)
        if not os.path.isfile(filename):
            raise ValueError(f"Invalid file path: {filename}")

        ch = self._channel
        if ch.name in "YUV":
            img = cv2.imread(filename)
            img = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)
        else:
            img = cv2.imread(filename)
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        return self._create_feature(img[:, :, self._channel.value], img_path)

    def _get_slice(self, image: ndarray, i: int, j: int) -> ndarray:
        return image[i * self._block_size:(i + 1) * self._block_size, j * self._block_size:(j + 1) * self._block_size]

    def _create_feature(self, image: ndarray, path: str) -> FeatureVector:
        results = []
        for _ in range(len(self._dct_coefficients)):
            results.append([])

        for x in range(image.shape[0] // self._block_size):
            for y in range(image.shape[1] // self._block_size):
                cur_slice: ndarray = self._get_slice(image, x, y)
                dct_coeffs = _apply_dct(cur_slice, self._dct_coefficients)
                for i in range(len(dct_coeffs)):
                    results[i].append(dct_coeffs[i])

        hists = []
        for result in results:
            hists.append(self._histoize(np.array(result)))

        return FeatureVector(hists, path)

    def _histoize(self, values: ndarray) -> tuple[ndarray, tuple[float, float, float]]:
        bin_min = _round_nearest(min(values), self._bin_width) - self._bin_width
        bin_max = _round_nearest(max(values), self._bin_width) + 2 * self._bin_width
        hist, bins = numpy.histogram(values, bins=numpy.arange(bin_min, bin_max, self._bin_width))
        return hist, \
            (_round_nearest(bins[0], self._bin_width), _round_nearest(bins[-1], self._bin_width), self._bin_width)


def main(img: str):
    fc = FeatureConfig(ChannelYUV.U, 8, 1, [(0, 0), (3, 2)])
    fe = FeatureExtractor(fc)
    cProfile.runctx("hallo(img)", locals={"hallo": fe.extract_feature_vector, "img": img, "fe": fe}, globals={},
                    sort="tottime")
    fv = fe.extract_feature_vector(img)
    for hist in fv.histograms:
        print("---------- New Histogram ----------")
        print(len(hist[0]))
        print(hist)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        main("example_images/decompressed/Buildings.001_jp2.png")
    else:
        main(sys.argv[1])
